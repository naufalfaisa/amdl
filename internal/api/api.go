package api

import (
	"encoding/json"
	"errors"
	"fmt"
	"net/http"
	"net/url"
	"sort"
	"time"

	"main/internal/structs"
	"main/internal/utils"
)

// GetUrlSong resolves a song URL to its album URL with the song focused.
func GetUrlSong(songUrl string, token string, lang string) (string, error) {
	storefront, songId := utils.CheckUrlSong(songUrl)
	manifest, err := GetSongResp(storefront, songId, lang, token)
	if err != nil {
		fmt.Println("\u26A0 Failed to get manifest:", err)
		return "", err
	}
	// Assuming manifest structure matches what was in main.go
	if len(manifest.Data) == 0 || len(manifest.Data[0].Relationships.Albums.Data) == 0 {
		return "", errors.New("no album data found for song")
	}
	albumId := manifest.Data[0].Relationships.Albums.Data[0].ID
	songAlbumUrl := fmt.Sprintf("https://music.apple.com/%s/album/1/%s?i=%s", storefront, albumId, songId)
	return songAlbumUrl, nil
}

// GetUrlArtistName fetches the artist name and ID.
func GetUrlArtistName(artistUrl string, token string, lang string) (string, string, error) {
	storefront, artistId := utils.CheckUrlArtist(artistUrl)
	req, err := http.NewRequest("GET", fmt.Sprintf("https://amp-api.music.apple.com/v1/catalog/%s/artists/%s", storefront, artistId), nil)
	if err != nil {
		return "", "", err
	}
	req.Header.Set("Authorization", fmt.Sprintf("Bearer %s", token))
	req.Header.Set("User-Agent", "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36")
	req.Header.Set("Origin", "https://music.apple.com")
	query := url.Values{}
	query.Set("l", lang)
	req.URL.RawQuery = query.Encode()
	do, err := http.DefaultClient.Do(req)
	if err != nil {
		return "", "", err
	}
	defer do.Body.Close()
	if do.StatusCode != http.StatusOK {
		return "", "", errors.New(do.Status)
	}
	obj := new(structs.AutoGeneratedArtist)
	err = json.NewDecoder(do.Body).Decode(&obj)
	if err != nil {
		return "", "", err
	}
	if len(obj.Data) == 0 {
		return "", "", errors.New("no artist data found")
	}
	return obj.Data[0].Attributes.Name, obj.Data[0].ID, nil
}

type ArtistItem struct {
	Name        string
	ReleaseDate string
	ID          string
	URL         string
}

// FetchArtistItems fetches all albums or music-videos for an artist.
func FetchArtistItems(artistUrl, token, relationship, lang string) ([]ArtistItem, error) {
	storefront, artistId := utils.CheckUrlArtist(artistUrl)
	Num := 0
	var items []ArtistItem

	for {
		req, err := http.NewRequest("GET", fmt.Sprintf("https://amp-api.music.apple.com/v1/catalog/%s/artists/%s/%s?limit=100&offset=%d&l=%s", storefront, artistId, relationship, Num, lang), nil)
		if err != nil {
			return nil, err
		}
		req.Header.Set("Authorization", fmt.Sprintf("Bearer %s", token))
		req.Header.Set("User-Agent", "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36")
		req.Header.Set("Origin", "https://music.apple.com")
		do, err := http.DefaultClient.Do(req)
		if err != nil {
			return nil, err
		}
		defer do.Body.Close()
		if do.StatusCode != http.StatusOK {
			return nil, errors.New(do.Status)
		}
		obj := new(structs.AutoGeneratedArtist)
		err = json.NewDecoder(do.Body).Decode(&obj)
		if err != nil {
			return nil, err
		}
		for _, album := range obj.Data {
			items = append(items, ArtistItem{
				Name:        album.Attributes.Name,
				ReleaseDate: album.Attributes.ReleaseDate,
				ID:          album.ID,
				URL:         album.Attributes.URL,
			})
		}
		Num = Num + 100
		if len(obj.Next) == 0 {
			break
		}
	}

	sort.Slice(items, func(i, j int) bool {
		dateI, _ := time.Parse("2006-01-02", items[i].ReleaseDate)
		dateJ, _ := time.Parse("2006-01-02", items[j].ReleaseDate)
		return dateI.Before(dateJ)
	})

	return items, nil
}
